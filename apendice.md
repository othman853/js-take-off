# Apêndice

REPL: Read-Eval-Print-Loop



Automação de build

## Pacotes ou dependências

Neste contexto, de forma simples, podemos entender _**pacote**_ como um pedaço de software reutilizável entre diferentes projetos. Pensando em uma analogia:

> Imaginando que o nosso projeto é construir um carro, precisamos de um motor para que o carro possa andar e, por consequência, um motor precisa de um sistema de refrigeração.

À partir daí \(se carros fossem como software\), temos duas opções:

* Projetar e construir um sistema de refrigeração para o motor

* Reutilizar um sistema de refrigeração já construído

Ainda seguindo a analogia, o repositório do npm é uma autopeça contendo milhares de partes de carros que já foram construídas por outras pessoas que tiveram que fazer carros semelhantes aos nossos. Poderíamos utilizar este repositório para encontrar e utilizar um sistema de refrigeração pronto, que foi projetado e testado por muita gente e que servisse para o nosso caso.

Além disso, o npm também facilita a forma como adicionamos as peças de um projeto. Ao invés de irmos até a loja buscar um novo componente do carro sempre que necessário, fazemos um pedido para a loja especificando tudo que precisamos e deixamos que a loja nos entregue tudo de maneira organizada sempre que for preciso.

Deixando o carro de lado e pensando em software novamente, podemos observar alguns exemplos reais de pacotes do npm:

* [Mongoose](https://www.npmjs.com/package/mongoose): uma biblioteca para facilitar a interação com bancos de dados MongoDB 
* [Moment](https://www.npmjs.com/package/moment): Uma biblioteca para manipular datas
* [Mocha](https://www.npmjs.com/package/mocha): Uma biblioteca de execução de testes
* [Express](https://www.npmjs.com/package/express): Um framework para construção de aplicações web baseadas em rotas



Uma alternativa ao npm: Yarn

